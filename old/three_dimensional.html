<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<style>
			body {
				margin: 0;
			}
			canvas {
				width: 100%;
				height: 100%;
			}
		</style>
		<title>three dimensional example</title>
	</head>
	<body>

		<!-- <script src="../node_modules/babel/node_modules/babel-core/browser-polyfill.min.js" charset="utf-8"></script> -->
		<script charset="utf-8" src="lindenmayer_ES5.js"></script>
		<script src="three.min.js"></script>
		<script src="controls_trackball.js"></script>

		<script>
			var camera, controls, scene, renderer, currentModel;
			var hilbertCurve;
			var X = new THREE.Vector3(1, 0, 0)
			var Y = new THREE.Vector3(0, 1, 0)
			var Z = new THREE.Vector3(0, 0, 1)
			var lineLength = 16

			var pushSegment = function() {
				console.log('push');
				var newSegment = currentModel.clone()
				scene.add(newSegment)
				currentModel.translateX(-(lineLength))
				newSegment.matrixAutoUpdate = false
				newSegment.updateMatrix()
			}

			init();
			animate();

			function init() {
				scene = new THREE.Scene()
				camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000)

				camera.position.x = -10


				controls = new THREE.TrackballControls(camera);

				controls.rotateSpeed = 1.0;
				controls.zoomSpeed = 1.2;
				controls.panSpeed = 0.8;

				controls.noZoom = false;
				controls.noPan = false;

				controls.staticMoving = true;
				controls.dynamicDampingFactor = 0.3;

				controls.keys = [
					65, 83, 68
				];

				controls.addEventListener('change', render);

				var light = new THREE.DirectionalLight(0xffffff);
				light.position
					.set(1, 1, 1);
				scene.add(light);

				light = new THREE.DirectionalLight(0x002288);
				light.position
					.set(-1, -1, -1);
				scene.add(light);

				light = new THREE.AmbientLight(0x222222);
				scene.add(light);

				renderer = new THREE.WebGLRenderer()
				renderer.setSize(window.innerWidth, window.innerHeight)
				document.body
					.appendChild(renderer.domElement)

				var angle = 90

				var geometry = new THREE.BoxGeometry(lineLength, lineLength/4, lineLength/4)
				var material = new THREE.MeshLambertMaterial({
					color: 0x00ff00,
					wireframe: false
				})
				var stack = []
				currentModel = new THREE.Mesh(geometry, material)
				currentModel.geometry.translate( -(lineLength/2), 0, 0 )


				hilbertCurve = new LSystem({
					word: 'Z',
					productions: [
						[
							'Z', 'YYYY|Z'
						],
						[
							'Y', 'XXXX+XXXX+XXXX+XXXX'
						], [
							'X', 'F+F+F^F^F-F-F^F^F'
						],
						[
							'A', 'B-F+CFC+F-D&F^D-F+&&CFC+F+B//'
						], [
							'B', 'A&F^CFB^F^D^^-F-D^|F^B|FC^F^A//'
						], [
							'C', '|D^|F^B-F+C^F^A&&FA&F^C+F+B^F^D//'
						], [
							'D', '|CFB-F+B|FA&F^A&&FB-F+B|FC//'
						]
					],
					finals: [
						[
							'F', pushSegment
						], [
							'+', function() {
								currentModel.rotation.y += ((Math.PI / 180) * angle)
							}
						], [
							'-', function() {
								currentModel.rotation.y += ((Math.PI / 180) * -angle)
							}
						], [
							'&', function() {
								currentModel.rotation.z += ((Math.PI / 180) * angle)
							}
						], [
							'^', function() {
								currentModel.rotation.z += ((Math.PI / 180) * -angle)
							}
						], [
							'\\', function() {
								currentModel.rotation.x += ((Math.PI / 180) * angle)
							}
						],[
							'<', function() {
								currentModel.rotation.x += ((Math.PI / 180) * angle)
							}
						], [
							'/', function() {
								currentModel.rotation.x += ((Math.PI / 180) * -angle)
							}
						], [
							'>', function() {
								currentModel.rotation.x += ((Math.PI / 180) * -angle)
							}
						], [
							'|', function() {
								currentModel.rotation.y += ((Math.PI / 180) * 180)
							}
						], [
							'[', function() {
								stack.push(currentModel.copy())
							}
						], [
							']', function() {
								currentModel = stack.pop()
							}
						]
					]
				})

				hilbertCurve.iterate(3)
				console.log(hilbertCurve.word)
				hilbertCurve.final()
			}



			function animate() {

				requestAnimationFrame(animate);
				controls.update();

			}

			function render() {

				renderer.render(scene, camera);

			}
			render();
		</script>

	</body>
</html>
