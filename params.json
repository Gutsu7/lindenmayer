{
  "name": "Lindenmayer",
  "tagline": "Feature complete classic L-Systems (branching, context sensitive, parametric) & multi-purpose modern L-System implementation that can take javascript functions as productions.",
  "body": "# Lindenmayer [![Build Status](https://travis-ci.org/nylki/lindenmayer.svg?branch=master)](https://travis-ci.org/nylki/lindenmayer)\r\n\r\nLindenmayer is  a [L-System](https://en.wikipedia.org/wiki/L-system) library using modern (ES6) JavaScript with focus on a concise syntax. The idea is to have a very powerful but simple base functionality, that can handle most use-cases by simply allowing anonymous functions as productions, which makes it very flexible in comparison to classic L-Systems.\r\n\r\nThe library can also parse (to some extend) classic L-System syntax as defined in Lindenmayers original work *Algorithmic Beauty of Plant* from 1990. (for example branches: `[]` or context sensitive productions: `<>`).\r\nMost stuff should work. I am currently working on parametric L-System support.\r\n\r\n**Right now it's under heavy development, so features and names are subject to change.\r\nI will remove this warning when I consider this library stable.**\r\n**Better docs and more examples are coming soon** :)\r\n\r\n## Examples\r\n[Interactive Examples](examples/webworker/)\r\n\r\n\r\nBasic usage:\r\n\r\n```.js\r\n// Initializing a L-System that produces the Koch-curve.\r\nlet kochcurve = new LSystem({\r\n      word: 'F++F++F',\r\n      productions: {'F': 'F-F++F-F'}\r\n})\r\nlet result = kochcurve.iterate(2)\r\n// result === 'F-F++F-F-F-F++F-F++F-F++F-F-F-F++F-F++F-F++F-F-F-F++F-F++F-F++F-F-F-F++F-F++F-F++F-F-F-F++F-F++F-F++F-F-F-F++F-F'\r\n```\r\n\r\nThere are multiple way to set productions, including javascript functions:\r\n\r\n```.js\r\nlet lsys = new LSystem()\r\nlsys.setWord('ABC')\r\n\r\n// simple production, using ES6 arrow function\r\nlsys.setProduction('B', () => 'F+F')\r\n\r\n// or same with just the String, both works\r\nlsys.setProduction('B', 'F+F')\r\n\r\n// simple stochastic production, producing `+F` with 10% probability, `FB+B` with 90%\r\nmyLSys.setProduction('B', () => (Math.random() < 0.1) ? 'F' : 'B')\r\n\r\n// simple context sensitive production rule, replacing `B` with `Z` if previous character is a A and next character is 'C'\r\nlsys.setProduction('B',\r\n  ({index, word}) => (word[index-1] === 'A') && (word[index+1] === 'C') ? 'Z' : 'B'\r\n)\r\n\r\n// or if you prefer the concise *classic* syntax for context sensitive productions:\r\nlsys.setProduction('A<B>C', 'Z')\r\n```\r\n\r\n## Usage\r\n\r\n### initializing\r\n\r\nYou can init a L-System in one go:\r\n\r\n```.js\r\n// Initializing a L-System that produces the Koch curve.\r\nlet kochcurve = new LSystem({\r\n      word: 'F++F++F',\r\n      productions: {'F': 'F-F++F-F'}\r\n})\r\nlet result = kochcurve.iterate(2)\r\n\r\n// Initialize L-System with multiple productions\r\nlet mylsys = new LSystem({\r\n      word: 'ABC',\r\n      productions: {\r\n        'A': 'A+',\r\n        'B': 'BA',\r\n        'C': 'ABC'\r\n      }\r\n})\r\n\r\n```\r\n\r\nIt's also possible to use functions as productions. This can be useful if you want to create **stochastic L-Systems**, like so:\r\n\r\n```.js\r\nlet lsys = new LSystem({\r\n      word: 'F++F++F',\r\n      productions: {'F': () => (Math.random() < 0.7) ? 'F-F++F-F' : 'F+F'}\r\n})\r\n\r\n// Productions can be changed later:\r\nlsys.setProduction('F', () => (Math.random() < 0.2) ? 'F-F++F-F' : 'F+F')\r\n```\r\n\r\nYou could also start with an empty L-System, and set all necessary parameters later on.\r\n\r\n```.js\r\nlet lsys = new LSystem()\r\nlsys.setWord('ABC')\r\nlsys.setProduction('A', 'AAB')\r\nlsys.setProduction('B', 'CB')\r\n```\r\n\r\nThis can be useful if you want to dynamically generate and edit L-Systems. For example, you might have a UI, where the user can add new production via a text box.\r\n\r\n### iterating\r\nNow that we have set up our L-System set, we want to generate new words:\r\n```.js\r\n// iterate once, log result to console:\r\nlet result = lsys.iterate()\r\nconsole.log(result))\r\n\r\n// iterate multiple times, then log result\r\nconsole.log(lsys.iterate(5))\r\n```\r\n\r\n\r\n### Final functions: Visualization and other post processing\r\nYou possibly want to visualize your L-Systems in some way.\r\nOf course you could iterate and parse the resulting string yourself. But `lindemayer` already got an API to define\r\nsuch postprocessing: `final` functions in an easy way. In those `final` functions you can define what should be done for each literal/character. The classic way to use L-Systems is to visualize words with [turtle graphics](https://en.wikipedia.org/wiki/Turtle_graphics).\r\nThe standard rules, found in Aristid Lindenmayer's and Przemyslaw Prusinkiewicz's classic work [Algorithmic Beauty of Plants](http://algorithmicbotany.org/papers/#abop) can be easily implented this way, to output the fractals onto a [HTML Canvas element](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API):\r\n\r\n```.html\r\n<body>\r\n\t<canvas id=\"canvas\" width=\"1000\" height=\"1000\"></canvas>\r\n</body>\r\n\r\n```\r\n\r\n```.js\r\n\r\nvar canvas = document.getElementById('canvas')\r\nvar ctx = canvas.getContext(\"2d\")\r\n\r\n// translate to center of canvas\r\nctx.translate(canvas.width/2, canvas/2)\r\n\r\n// initialize a koch curve L-System that uses final functions\r\n// to draw the fractal onto a Canvas element.\r\n// F: draw a line with length relative to the current iteration (half the previous length for each step)\r\n//    and translates the current position to the end of the line\r\n// +: rotates the canvas 60 degree\r\n// -: rotates the canvas -60 degree\r\n\r\nvar koch = new LSystem({\r\n  word: 'F++F++F',\r\n  productions: {'F': 'F-F++F-F'},\r\n  finals: [\r\n    ['+', () => { ctx.rotate((Math.PI/180) * 60) }],\r\n    ['-', () => { ctx.rotate((Math.PI/180) * -60) }],\r\n    ['F', () => {\r\n      ctx.beginPath()\r\n      ctx.moveTo(0,0)\r\n      ctx.lineTo(0, 50/(koch.iterations + 1))\r\n      ctx.stroke()\r\n      ctx.translate(0, 50/(koch.iterations + 1))}\r\n     ]\r\n   ]\r\n})\r\n\r\nkoch.iterate(3)\r\nkoch.final()\r\n```\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}