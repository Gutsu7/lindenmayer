{
  "name": "Lindenmayer",
  "tagline": "Feature complete classic L-Systems (branching, context sensitive, parametric) & multi-purpose modern L-System implementation that can take javascript functions as productions.",
  "body": "# Lindenmayer [![Build Status](https://travis-ci.org/nylki/lindenmayer.svg?branch=master)](https://travis-ci.org/nylki/lindenmayer)\r\n\r\nLindenmayer is  a [L-System](https://en.wikipedia.org/wiki/L-system) library using modern (ES6) JavaScript with focus on a concise syntax. The idea is to have a very powerful but simple base functionality, that can handle most use-cases by simply allowing anonymous functions as productions, which makes it very flexible in comparison to classic L-Systems.\r\n\r\nThe library can also parse (to some extend) classic L-System syntax as defined in Lindenmayers original work *Algorithmic Beauty of Plants* from 1990. (for example branches: `[]` or context sensitive productions: `<>`).\r\nMost stuff should work. I am currently working on parametric L-System support.\r\n\r\n**Right now it's under heavy development, so features and names are subject to change.\r\nI will remove this warning when I consider this library stable.**\r\n**Better docs and more examples are coming soon** :)\r\n\r\n## Examples\r\n-  [codepen collection (editable!)](https://codepen.io/collection/AVvqeg/)\r\n-  [Interactive L-System builder](http://nylki.github.io/lindenmayer/examples/webworker)\r\n\r\n## Basic Usage\r\n\r\n```.js\r\n// Initializing a L-System that produces the Koch-curve\r\nlet kochcurve = new LSystem({\r\n      axiom: 'F++F++F',\r\n      productions: {'F': 'F-F++F-F'}\r\n})\r\n// Iterate the L-System two times and log the result.\r\nlet result = kochcurve.iterate(2)\r\nconsole.log(result)\r\n//'F-F++F-F-F-F++F-F++F-F++F-F-F-F++F-F++F-F++F-F-F-F++F-F++F-F++F-F-F-F++F-F++F-F++F-F-F-F++F-F++F-F++F-F-F-F++F-F'\r\n```\r\n\r\nThere are multiple ways to set productions, including javascript functions:\r\n\r\n```.js\r\nlet lsys = new LSystem()\r\nlsys.setAxiom('ABC')\r\n\r\n// simple production, using ES6 arrow function\r\nlsys.setProduction('B', () => 'F+F')\r\n\r\n// or same with just the String, both works\r\nlsys.setProduction('B', 'F+F')\r\n\r\n// simple stochastic production, producing `F` with 10% probability, `B` with 90%\r\nmyLSys.setProduction('B', () => (Math.random() < 0.1) ? 'F' : 'B')\r\n\r\n// simple context sensitive production rule, replacing `B` with `Z` if previous character is a A and next character is 'C'\r\nlsys.setProduction('B',\r\n  ({index, currentAxiom}) => (currentAxiom[index-1] === 'A') && (currentAxiom[index+1] === 'C') ? 'Z' : 'B'\r\n)\r\n\r\n// or if you prefer the concise *classic* syntax for context sensitive productions:\r\nlsys.setProduction('A<B>C', 'Z')\r\n```\r\n\r\n## initializing\r\n\r\nYou can init a L-System object with the `new` keyword:\r\n```.js\r\nlet myCoolLSystem = new LSystem(options)\r\n```\r\n\r\n`options` may contain:\r\n- `axiom`: A String or an Array of Objects to set the initial axiom (sometimes called axiom, start or initiator).\r\n- `productions`: key-value Object to set the productions from one symbol to its axiom. Used when calling `iterate()`. A production can be either a String or a Function (see below.)\r\n- `finals`: Optional key-value Object to set Functions be executed for each symbol in sequential order. Useful for visualization. Used when calling `final()`.\r\n\r\nadvanced options (see [API docs](not yet created) for details):\r\n\r\n- `branchSymbols`: A String of two characters. Only used when working with classic context sensitive productions. The first symbol is treated as start of a branch, the last symbol as end of a branch. (default: `\"[]\"`, but only when using classic CS syntax)\r\n- `ignoredSymbols`: A String of characters to ignore when using context sensitive productions. (default: `\"+-&^/|\\\\\"`, but only when using classic CS syntax)\r\n- `classicParametricSyntax`: A Bool to enable *experimental* parsing of parametric L-Systems as defined in Lindenmayers book *Algorithmic Beauty of Plants*. (default: `false`)\r\n\r\nMost often you will find yourself only setting `axiom`, `productions` and `finals`.\r\n\r\n## setting an axiom\r\nAs seen in the first section you can simply set your axiom when you init your L-System.\r\n\r\n```.js\r\nlet lsys = new LSystem({\r\n      axiom: 'F++F++F'\r\n})\r\n```\r\n\r\nYou can also set an axiom after initialization:\r\n\r\n```.js\r\nlet lsys = new LSystem({\r\n      axiom: 'F++F++F'\r\n})\r\nlsys.setAxiom('F-F-F')\r\n```\r\n\r\n\r\n## setting productions\r\nProductions define how the axioms symbols get transformed. For example, if you want all `A`s to be replaced by `B` in your axiom, you could construct the following production:\r\n```.js\r\nlet lsystem = new LSystem({\r\n  axiom: 'ABC',\r\n  productions: {'A': 'B'}\r\n})\r\n//lsystem.iterate() === 'BBC'\r\n```\r\n\r\nYou can set as many productions on initialization as you like:\r\n\r\n```.js\r\nlet lsystem = new LSystem({\r\n      axiom: 'ABC',\r\n      productions: {\r\n        'A': 'A+',\r\n        'B': 'BA',\r\n        'C': 'ABC'\r\n      }\r\n})\r\n// lsystem.iterate() === 'A+BAABC'\r\n```\r\n\r\nYou could also start with an empty L-System object, and use `setAxiom()` and `setProduction()` to edit the L-System later:\r\n\r\n```.js\r\nlet lsys = new LSystem()\r\nlsys.setAxiom('ABC')\r\nlsys.setProduction('A', 'AAB')\r\nlsys.setProduction('B', 'CB')\r\n```\r\n\r\nThis can be useful if you want to dynamically generate and edit L-Systems. For example, you might have a UI, where the user can add new production via a text box.\r\n\r\nA major feature of Lindenmayer.js is the possibility to use functions as productions, which is especially useful for stochasic L-Systems:\r\n\r\n```.js\r\n// This L-System produces `F+` with a 70% probability and `F-` with 30% probability\r\nlet lsys = new LSystem({\r\n      axiom: 'F++F++F',\r\n      productions: {'F': () => (Math.random() <= 0.7) ? 'F+' : 'F-'}\r\n})\r\n\r\n// Productions can also be changed later:\r\nlsys.setProduction('F', () => (Math.random() < 0.2) ? 'F-F++F-F' : 'F+F')\r\n```\r\n\r\nIf you are using functions as productions, your function can make use of a number of additional parameters:\r\n\r\n```.js\r\nlsys.setAxiom('FFFFF')\r\nlsys.setProduction('F', (parameters) => {\r\n  // Use the `index` to determine where inside the current axiom, the function is applied on.\r\n  if(parameters.index === 3) return 'X';\r\n})\r\n// lsys.iterate() === FFXFF\r\n```\r\n\r\n**parameters**:\r\n- `index`: the index inside the axiom\r\n- `currentAxiom`: the current full axiom/word\r\n- `part`: the current part (symbol or object) the production is applied on. This is only useful if you are using parametric L-Systems (see last chapter) to have access to parameters of a symbol.\r\n\r\n\r\n\r\n### iterating\r\nNow that we have set up our L-System set, we want to generate new axioms with `iterate()`:\r\n\r\n```.js\r\n// Iterate once\r\nlsys.iterate();\r\n\r\n// Iterate n-times\r\nlsys.iterate(5);\r\n```\r\n\r\n### Getting Results\r\n`iterate()` conveniently returns the resulting string:\r\n\r\n```.js\r\nconsole.log(lsys.iterate())\r\n```\r\n\r\nIf you want to fetch the result later, use `getString()`:\r\n\r\n```.js\r\nlsys.iterate()\r\nconsole.log(lsys.getString())\r\n```\r\n\r\n\r\n### Putting it all together\r\n#### Final functions: Visualization and other post processing\r\n\r\nMost likely you want to visualize or post-process your L-Systems output in some way.\r\nYou could iterate and parse the result yourself, however `lindemayer` already offers an easy way to define\r\nsuch postprocessing: *final* functions. In those final functions you can define what should be done for each literal/character. The classic way to use L-Systems is to visualize axioms with [turtle graphics](https://en.wikipedia.org/wiki/Turtle_graphics).\r\nThe standard rules, found in Aristid Lindenmayer's and Przemyslaw Prusinkiewicz's classic work [Algorithmic Beauty of Plants](http://algorithmicbotany.org/papers/#abop) can be easily implented this way, to output the fractals onto a [Canvas](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API).\r\n\r\n\r\nYou can fiddle with the following example in [this codepen](http://codepen.io/nylki/pen/QNYqzd)!\r\n```.html\r\n<body>\r\n\t<canvas id=\"canvas\" width=\"1000\" height=\"1000\"></canvas>\r\n</body>\r\n\r\n```\r\n\r\n```.js\r\nvar canvas = document.getElementById('canvas')\r\nvar ctx = canvas.getContext(\"2d\")\r\n\r\n// translate to center of canvas\r\nctx.translate(canvas.width / 2, canvas.height / 4)\r\n\r\n// initialize a koch curve L-System that uses final functions\r\n// to draw the fractal onto a Canvas element.\r\n// F: draw a line with length relative to the current iteration (half the previous length for each step)\r\n//    and translates the current position to the end of the line\r\n// +: rotates the canvas 60 degree\r\n// -: rotates the canvas -60 degree\r\n\r\nvar koch = new LSystem({\r\n  axiom: 'F++F++F',\r\n  productions: {'F': 'F-F++F-F'},\r\n  finals: {\r\n    '+': () => { ctx.rotate((Math.PI/180) * 60) },\r\n    '-': () => { ctx.rotate((Math.PI/180) * -60) },\r\n    'F': () => {\r\n      ctx.beginPath()\r\n      ctx.moveTo(0,0)\r\n      ctx.lineTo(0, 40/(koch.iterations + 1))\r\n      ctx.stroke()\r\n      ctx.translate(0, 40/(koch.iterations + 1))}\r\n   }\r\n})\r\n\r\nkoch.iterate(3)\r\nkoch.final()\r\n```\r\n\r\nAnd the result:\r\n\r\n[![Resulting image](https://cloud.githubusercontent.com/assets/1710598/15099304/09a530d6-1552-11e6-8261-fd302c5c89f6.png)](http://codepen.io/nylki/pen/QNYqzd)\r\n\r\n\r\n## Advanced Usage\r\n### Parametric L-Systems\r\n\r\nWhen defining axioms you may also use an Array of Objects instead of basic Strings. This makes the library very flexible because you can insert custom parameters into your symbols. Eg. a symbol like a `A` may contain a `food` variable to simulate organic growth when combined with a random() function:\r\n\r\n```.js\r\nlet parametricLsystem = new lsys.LSystem({\r\n  axiom: [\r\n    {symbol: 'A', food:0.5},\r\n    {symbol: 'B'},\r\n    {symbol: 'A', , food:0.1},\r\n    {symbol: 'C'}\r\n  ],\r\n  // And then do stuff with those custom parameters in productions:\r\n  productions: {\r\n    'A': ({part, index}) => {\r\n      // split A into one A and a new B if it ate enough:\r\n      if(part.food >= 1.0) {\r\n        return [{symbol: 'A', food:0}, {symbol: 'B', food:0}]        \r\n      } else {\r\n        // otherwise eat a random amount of food\r\n        part.food += Math.random() * 0.1;\r\n        return part;\r\n      }\r\n    }\r\n  }\r\n});\r\n\r\n// parametricLsystem.iterate(60);\r\n// Depending on randomness:\r\n// parametricLsystem.getString() ~= 'ABBBBBABBBC';\r\n// The first part of B's has more B's because the first A got more initial food which in the end made a small difference, as you can see.\r\n```\r\n\r\nAs you can see above, you need to explicitly define the `symbol` value, so the correct production can be applied.\r\n\r\n#### Classic Parametric L-System syntax\r\nthey loook like `A -> A(1,2)B(5,2)`.\r\nAre planned, but not yet fully implemented. Stay tuned!\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}